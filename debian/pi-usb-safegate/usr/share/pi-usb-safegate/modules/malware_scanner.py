"""
Malware Scanner Module
Uses ClamAV to scan files for viruses and malware
"""

import os
import subprocess
import logging
import tempfile
import shutil
from pathlib import Path


class MalwareScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.clamav_available = self._check_clamav_availability()
        
    def _check_clamav_availability(self):
        try:
            result = subprocess.run(['clamscan', '--version'], 
                                  capture_output=True, text=True, check=True)
            self.logger.info(f"ClamAV detected: {result.stdout.strip()}")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.logger.warning("ClamAV not found. Install with: sudo apt-get install clamav clamav-daemon")
            return False
            
    def update_virus_database(self):
        if not self.clamav_available:
            self.logger.error("ClamAV not available")
            return False
            
        try:
            self.logger.info("Updating virus database...")
            result = subprocess.run(['sudo', 'freshclam'], 
                                  capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                self.logger.info("Virus database updated successfully")
                return True
            else:
                self.logger.warning(f"Database update completed with warnings: {result.stderr}")
                return True
                
        except subprocess.TimeoutExpired:
            self.logger.error("Database update timed out")
            return False
        except Exception as e:
            self.logger.error(f"Error updating virus database: {str(e)}")
            return False
            
    def scan_file(self, file_path):
        if not self.clamav_available:
            self.logger.warning("ClamAV not available, skipping scan")
            return {'infected': False, 'threat': None}
            
        try:
            result = subprocess.run(['clamscan', '--no-summary', file_path],
                                  capture_output=True, text=True, check=False)
            
            if result.returncode == 0:
                return {'infected': False, 'threat': None}
            elif result.returncode == 1:
                threat_info = self._parse_threat_info(result.stdout)
                self.logger.warning(f"Infected file detected: {file_path} - {threat_info}")
                return {'infected': True, 'threat': threat_info}
            else:
                self.logger.error(f"Error scanning file {file_path}: {result.stderr}")
                return {'infected': False, 'threat': None, 'error': result.stderr}
                
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {str(e)}")
            return {'infected': False, 'threat': None, 'error': str(e)}
            
    def _parse_threat_info(self, scan_output):
        lines = scan_output.strip().split('\n')
        for line in lines:
            if 'FOUND' in line:
                parts = line.split(':')
                if len(parts) >= 2:
                    return parts[1].strip().replace(' FOUND', '')
        return 'Unknown threat'
        
    def scan_usb_drive(self, mount_point):
        self.logger.info(f"Starting comprehensive scan of {mount_point}")
        
        scan_result = {
            'safe_files': [],
            'infected_files': [],
            'scan_errors': [],
            'total_files': 0,
            'total_size': 0
        }
        
        if not os.path.exists(mount_point):
            self.logger.error(f"Mount point {mount_point} does not exist")
            return scan_result
            
        try:
            for root, dirs, files in os.walk(mount_point):
                for file in files:
                    file_path = os.path.join(root, file)
                    
                    try:
                        file_stat = os.stat(file_path)
                        file_size = file_stat.st_size
                        scan_result['total_files'] += 1
                        scan_result['total_size'] += file_size
                        
                        if file_size > 100 * 1024 * 1024:  # 100MB limit
                            self.logger.warning(f"Skipping large file: {file_path} ({file_size} bytes)")
                            continue
                            
                        scan_file_result = self.scan_file(file_path)
                        
                        if 'error' in scan_file_result:
                            scan_result['scan_errors'].append({
                                'file': file_path,
                                'error': scan_file_result['error']
                            })
                        elif scan_file_result['infected']:
                            scan_result['infected_files'].append({
                                'file': file_path,
                                'threat': scan_file_result['threat']
                            })
                        else:
                            scan_result['safe_files'].append(file_path)
                            
                    except OSError as e:
                        self.logger.warning(f"Cannot access file {file_path}: {str(e)}")
                        scan_result['scan_errors'].append({
                            'file': file_path,
                            'error': str(e)
                        })
                        
        except Exception as e:
            self.logger.error(f"Error during USB drive scan: {str(e)}")
            
        self.logger.info(f"Scan complete: {len(scan_result['safe_files'])} safe, "
                        f"{len(scan_result['infected_files'])} infected, "
                        f"{len(scan_result['scan_errors'])} errors")
        
        return scan_result
        
    def quarantine_file(self, file_path, quarantine_dir="/tmp/quarantine"):
        try:
            os.makedirs(quarantine_dir, exist_ok=True)
            
            file_name = os.path.basename(file_path)
            quarantine_path = os.path.join(quarantine_dir, f"quarantine_{file_name}")
            
            shutil.move(file_path, quarantine_path)
            
            os.chmod(quarantine_path, 0o000)
            
            self.logger.info(f"File quarantined: {file_path} -> {quarantine_path}")
            return quarantine_path
            
        except Exception as e:
            self.logger.error(f"Error quarantining file {file_path}: {str(e)}")
            return None
            
    def scan_directory_batch(self, directory_path):
        if not self.clamav_available:
            self.logger.warning("ClamAV not available, skipping batch scan")
            return {'infected': False, 'infected_files': []}
            
        try:
            result = subprocess.run(['clamscan', '-r', '--infected', '--no-summary', directory_path],
                                  capture_output=True, text=True, check=False)
            
            infected_files = []
            
            if result.returncode == 1:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if 'FOUND' in line:
                        file_path = line.split(':')[0].strip()
                        threat = self._parse_threat_info(line)
                        infected_files.append({'file': file_path, 'threat': threat})
                        
            return {
                'infected': len(infected_files) > 0,
                'infected_files': infected_files
            }
            
        except Exception as e:
            self.logger.error(f"Error in batch scan: {str(e)}")
            return {'infected': False, 'infected_files': []}